# Lines configured by zsh-newuser-install
HISTFILE=~/.zhistory
HISTSIZE=SAVEHIST=10000
setopt extendedglob
setopt sharehistory
bindkey -v
# End of lines configured by zsh-newuser-install
# The following lines were added by compinstall
zstyle :compinstall filename '/Users/kohschooley/.zshrc'

autoload -Uz compinit
compinit
# End of lines added by compinstall

# Following section sourced from http://askubuntu.com/questions/1577/moving-from-bash-to-zsh
# Tab completion from both ends.
setopt completeinword

# Tab completion should be case-insensitive
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'

# Add personal bin to PATH
export PATH=$PATH:~/bin

# Disable cowsay for ansible
export ANSIBLE_NOCOWS=1

# Color output for ls
alias ls='ls -G'

# I use get-screenshot alot, lets shorten it.
alias screenshot="get-screenshot"

# Shortcuts for ls.
alias ll='ls -l'
alias la='ls -a'

# Interpret paths as implicit cd's
setopt auto_cd

# Colors for ls
zstyle ':completion:*' list-colors 'di=34:ln=35:so=32:pi=33:ex=31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'

#---------------------------------------------------------------------
# System specific settings (color prompt, loaded modules, etc.)
#---------------------------------------------------------------------


# SSH config, from https://bitbucket.org/crosschx/ssh-config
alias ssh='cat ~/.ssh/config.d/* > ~/.ssh/config; ssh'

# Prompt stuff
function precmd {

    local TERMWIDTH
    (( TERMWIDTH = ${COLUMNS} - 1 ))


    ###
    # Truncate the path if it's too long.
    
    PR_FILLBAR=""
    PR_PWDLEN=""
    
    local promptsize=${#${(%):---(%n@%m:%l)---()--}}
    local pwdsize=${#${(%):-%~}}
    
    if [[ "$promptsize + $pwdsize" -gt $TERMWIDTH ]]; then
        ((PR_PWDLEN=$TERMWIDTH - $promptsize))
    else
    PR_FILLBAR="\${(l.(($TERMWIDTH - ($promptsize + $pwdsize)))..${PR_HBAR}.)}"
    fi


    ###
    # Get APM info.

    if which ibam > /dev/null; then
    PR_APM_RESULT=`ibam --percentbattery`
    # The following lines interfere with Atom, the text editor.  Atom has a command called apm.
    # I don't think I need this line, so I'm commenting it out.
    #elif which apm > /dev/null; then
    #PR_APM_RESULT=`apm`
    fi
}


setopt extended_glob
preexec () {
    if [[ "$TERM" == "screen" ]]; then
    local CMD=${1[(wr)^(*=*|sudo|-*)]}
    echo -n "\ek$CMD\e\\"
    fi
}


setprompt () {
    ###
    # Need this so the prompt will work.

    setopt prompt_subst


    ###
    # See if we can use colors.

    autoload colors zsh/terminfo
    if [[ "$terminfo[colors]" -ge 8 ]]; then
    colors
    fi
    for color in RED GREEN YELLOW BLUE MAGENTA CYAN WHITE; do
    eval PR_$color='%{$terminfo[bold]$fg[${(L)color}]%}'
    eval PR_LIGHT_$color='%{$fg[${(L)color}]%}'
    (( count = $count + 1 ))
    done
    PR_NO_COLOUR="%{$terminfo[sgr0]%}"


    ###
    # See if we can use extended characters to look nicer.
    
    typeset -A altchar
    set -A altchar ${(s..)terminfo[acsc]}
    PR_SET_CHARSET="%{$terminfo[enacs]%}"
    PR_SHIFT_IN="%{$terminfo[smacs]%}"
    PR_SHIFT_OUT="%{$terminfo[rmacs]%}"
    PR_HBAR=${altchar[q]:--}
    PR_ULCORNER=${altchar[l]:--}
    PR_LLCORNER=${altchar[m]:--}
    PR_LRCORNER=${altchar[j]:--}
    PR_URCORNER=${altchar[k]:--}

    
    ###
    # Decide if we need to set titlebar text.
    
    case $TERM in
    xterm*)
        PR_TITLEBAR=$'%{\e]0;%(!.-=*[ROOT]*=- | .)%n@%m:%~ | ${COLUMNS}x${LINES} | %y\a%}'
        ;;
    screen)
        PR_TITLEBAR=$'%{\e_screen \005 (\005t) | %(!.-=[ROOT]=- | .)%n@%m:%~ | ${COLUMNS}x${LINES} | %y\e\\%}'
        ;;
    *)
        PR_TITLEBAR=''
        ;;
    esac
    
    
    ###
    # Decide whether to set a screen title
    if [[ "$TERM" == "screen" ]]; then
    PR_STITLE=$'%{\ekzsh\e\\%}'
    else
    PR_STITLE=''
    fi
    
    
    ###
    # APM detection
    
    if which ibam > /dev/null; then
    PR_APM='$PR_RED${${PR_APM_RESULT[(f)1]}[(w)-2]}%%(${${PR_APM_RESULT[(f)3]}[(w)-1]})$PR_LIGHT_BLUE:'
    #elif which apm > /dev/null; then
    #PR_APM='$PR_RED${PR_APM_RESULT[(w)5,(w)6]/\% /%%}$PR_LIGHT_BLUE:'
    else
    PR_APM=''
    fi
    
    
    ###
    # Finally, the prompt.

    PROMPT='$PR_SET_CHARSET$PR_STITLE${(e)PR_TITLEBAR}\
$PR_CYAN$PR_SHIFT_IN$PR_ULCORNER$PR_BLUE$PR_HBAR$PR_SHIFT_OUT(\
$PR_GREEN%(!.%SROOT%s.%n)$PR_GREEN@%m:%l\
$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_CYAN$PR_HBAR${(e)PR_FILLBAR}$PR_BLUE$PR_HBAR$PR_SHIFT_OUT(\
$PR_MAGENTA%$PR_PWDLEN<...<%~%<<\
$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_CYAN$PR_URCORNER$PR_SHIFT_OUT\

$PR_CYAN$PR_SHIFT_IN$PR_LLCORNER$PR_BLUE$PR_HBAR$PR_SHIFT_OUT(\
%(?..$PR_LIGHT_RED%?$PR_BLUE:)\
${(e)PR_APM}$PR_YELLOW%D{%H:%M}\
$PR_LIGHT_BLUE:%(!.$PR_RED.$PR_WHITE)%#$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
$PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
$PR_NO_COLOUR '

    RPROMPT=' $PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_BLUE$PR_HBAR$PR_SHIFT_OUT\
($PR_YELLOW%D{%a,%b%d}$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_CYAN$PR_LRCORNER$PR_SHIFT_OUT$PR_NO_COLOUR'

    PS2='$PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
$PR_BLUE$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT(\
$PR_LIGHT_GREEN%_$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
$PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT$PR_NO_COLOUR '
}

setprompt

# VIM shall rule them all, Emacs is for chumps.
export EDITOR="/usr/bin/vim"

# Add function to add all necessary ssh keys
add-keys() {
    ssh-add ~/.ssh/secure.crosschx.com/secure_rsa ~/.ssh/pi_rsa ~/.ssh/id_rsa ~/.ssh/bitbucket_rsa
}

# Add ssh keys on boot to prevent yelling fuck later
env | grep -q SSH_AUTH_SOCK
if [[ $? -ne 0 ]]; then
   ssh-agent
fi

ssh-add -l | grep -q '/bitbucket'
if [[ $? -ne 0 ]]; then
   ssh-add -K ~/.ssh/bitbucket_rsa
   echo
fi

ssh-add -l | grep -q pi_rsa
if [[ $? -ne 0 ]]; then
   ssh-add -K ~/.ssh/pi_rsa
   echo
fi


ssh-add -l | grep -q '/dev'
if [[ $? -ne 0 ]]; then
   ssh-add -K ~/.ssh/dev.crosschx.com/dev_rsa
   echo
fi

ssh-add -l | grep -q '/mgmt'
if [[ $? -ne 0 ]]; then
   ssh-add -K ~/.ssh/mgmt.crosschx.com/mgmt_rsa
   echo
fi

if [[ $? -ne 0 ]]; then
   ssh-add -K ~/.ssh/secure.crosschx.com/secure_rsa
   echo
fi

export AWS_SECRET_KEY=tWseitEyj6Ba7GdGahUxm0w35sUkzgwWlK7r/0ot
export AWS_ACCESS_KEY=AKIAJ5H4CHFCWCVUHKCQ

bindkey "^[f" forward-word
bindkey "^[b" backward-word
